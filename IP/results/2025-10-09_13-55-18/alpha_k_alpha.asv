%% MATLAB Code: Normalized Level Set Comparison (Inverted Pendulum vs. Double Integrator)

clear
clc
close all
format long

% --- 0. Define File Paths and Common Parameters ---

% File path for the Inverted Pendulum (IP) data
ip_file_path = '/Users/saber/Desktop/Safety/IP/results/2025-10-09_13-55-18/AVR_gain_map.csv';

% File path for the Double Integrator (DI) data
di_file_path = '/Users/saber/Desktop/Safety/DI/results/2025-10-08_23-15-25/AVR_gain_map.csv';

% Define the common alpha thresholds (e.g., from 0 to 1, in steps of 0.001)
levels = 0:0.001:1;
num_levels = length(levels);

% --- 1. Processing Function (to avoid repeating code) ---
% This function calculates the normalized level set for a given matrix g.
calculate_normalized_levels = @(g) computeLevelSet(g, levels, num_levels);

% --- 2. Process INVERTED PENDULUM (IP) Data ---
try
    g_ip = readmatrix(ip_file_path);
    [y_ip, alpha_1_prop_ip] = calculate_normalized_levels(g_ip);
    success_ip = true;
catch
    warning('Could not load IP data from: %s', ip_file_path);
    y_ip = zeros(1, num_levels); % Use placeholder data
    success_ip = false;
end

% --- 3. Process DOUBLE INTEGRATOR (DI) Data ---
try
    g_di = readmatrix(di_file_path);
    [y_di, alpha_1_prop_di] = calculate_normalized_levels(g_di);
    success_di = true;
catch
    warning('Could not load DI data from: %s', di_file_path);
    y_di = zeros(1, num_levels); % Use placeholder data
    success_di = false;
end

% --- 4. Prepare Plot Data ---
% The X-axis (levels) must run from 1 to 0, so reverse the order for the plot.
x_plot = fliplr(levels);
y_plot_ip = fliplr(y_ip);
y_plot_di = fliplr(y_di);

% --- 5. Generate and Customize Plot (with requested enhancements) ---

% Set up figure and enable LaTeX rendering
figure('Position', [100, 100, 800, 500]); 
set(groot, 'DefaultTextInterpreter', 'latex'); % Set default interpreter to LaTeX
set(groot, 'DefaultLegendInterpreter', 'latex');
set(groot, 'DefaultAxesFontSize', 14);       % Increase axes font size

hold on;

% --- Plotting with LineWidth = 4 ---
if success_ip
    plot(x_plot, y_plot_ip, 'b-', 'LineWidth', 4, 'DisplayName', 'Inverted Pendulum (IP)');
end
if success_di
    plot(x_plot, y_plot_di, 'r--', 'LineWidth', 4, 'DisplayName', 'Double Integrator (DI)');
end

hold off;

% --- Title and Labels using LaTeX ---
title('Normalized Level Set Comparison', 'FontSize', 16);
% Use \alpha for alpha, \rightarrow for the arrow
xlabel('$\alpha$,'FontSize', 16);
% Use \alpha_1 for alpha_1 in the fraction
ylabel('Normalized Level Set Size (Proportion / $\alpha_1$)', 'FontSize', 16);

grid on;
legend('Location', 'northwest');

% --- Axis Configuration ---
% CORRECTED AXIS INVERSION:
xlim([0 1]); 
set(gca, 'XDir', 'reverse'); 

% --- 6. Save Plot as PDF ---
saveas(gcf, 'Normalized_Level_Set_Comparison.pdf');

disp('Plot generated and saved as "Normalized_Level_Set_Comparison.pdf"');
disp('Note: LaTeX rendering and increased font/line size applied.');

%% Local Function for Level Set Calculation

function [normalized_levels, alpha_1_proportion] = computeLevelSet(g, levels, num_levels)
    total_elements = numel(g);
    
    % Calculate the normalization factor
    alpha_1_size = nnz(g >= 1);
    alpha_1_proportion = alpha_1_size / total_elements;
    
    normalized_levels = zeros(1, num_levels);
    
    if alpha_1_proportion == 0
        % If normalization factor is zero, return the un-normalized proportion
        for i = 1:num_levels
            count = nnz(g >= levels(i));
            normalized_levels(i) = count / total_elements;
        end
    else
        % Normal case: calculate and normalize
        for i = 1:num_levels
            count = nnz(g >= levels(i));
            level_set_proportion = count / total_elements;
            normalized_levels(i) = level_set_proportion / alpha_1_proportion;
        end
    end
end